To give you an idea of the project, here's a simple example:
Let's say the client wants to send a message to the server.

    The client converts the message into binary code.
    The client sends the binary code bit by bit to the server using signals.
    The server receives the bits and reconstructs the message.
    The server acknowledges the successful reception by sending a signal back to the client.

Note: The actual implementation will be more complex, but this example provides a high-level understanding of the project.

Remember, you are not allowed to use functions other than the ones mentioned above. The project requires you to implement the communication using signals effectively
---------------
In Unix-like systems, signals are a way to communicate events or notifications between processes. A signal is an asynchronous notification sent to a process to inform it about a specific event. The sending process can be the operating system, another process, or the process itself.

In the Minitalk project, you will use signals to establish communication between the client and the server. Here's a step-by-step overview of how they can communicate through signals:

    Server Setup:
        The server program starts by setting up a signal handler using the sigaction function. The signal handler is a function that gets executed when a specific signal is received.
        The server specifies the signal it wants to handle using the sigaction function and defines the corresponding signal handler function.
        The server waits for incoming signals using the pause function, which pauses the execution of the program until a signal is received.

    Client Sending Data:
        The client program converts the message it wants to send into binary code or some other suitable format.
        For each bit or element of the message, the client sends a signal to the server using the kill function. The server's process ID is used as the target of the signal.
        The client can use the sleep or usleep functions to introduce delays between sending consecutive signals to ensure the server has enough time to handle each signal.

    Server Receiving and Handling Signals:
        When the server receives a signal, the signal handler function specified in the server setup is executed.
        The server's signal handler can use the received signal to determine the corresponding bit or element of the message.
        The server processes the received bit or element and stores it or performs any necessary operations.

    Acknowledgment and Synchronization:
        After processing each received signal, the server may need to acknowledge the successful reception of the bit or element to the client.
        The server can send a signal back to the client using the kill function, similar to how the client sends signals to the server.
        The client can set up a signal handler to receive the acknowledgment from the server and take appropriate action based on the received acknowledgment.

This process continues until the client has sent all the bits or elements of the message, and the server has received and processed them.

Note that signals are limited in the amount of information they can carry (typically a single integer value). Therefore, in the Minitalk project, you will need to use multiple signals to transmit a message effectively.

The precise implementation details, such as how to encode and decode the message, manage synchronization, and handle errors, will depend on your specific implementation and design choices within the constraints of the project.

use sigaction,|
sigemptyset return 0 on success and -1 on error.
sigaddset add signal signum from set ?
kill use to send any signal to any process, specified by PID
getpid returns process ID of calling process.
pause causes the calling process to sleep until a signal is delivered
sleep causes the process to sleep untilk x seconds or signal that is not ignored comes and wakes it up.
exit terminates a process.










